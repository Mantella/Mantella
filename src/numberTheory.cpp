#include "mantella_bits/numberTheory.hpp"

// C++ standard library
#include <algorithm>
#include <cmath>

// Mantella
#include "mantella_bits/armadillo.hpp"
#include "mantella_bits/assert.hpp"

namespace mant {
  arma::Mat<double> hammersleySet(
      const arma::Col<arma::uword>& base,
      const arma::Col<arma::uword>& seed,
      const arma::uword numberOfElements) {
    verify(base.n_elem == seed.n_elem, "hammersleySet: The number of dimensions of the base parameter must match the number of dimensions of the seed parameter.");

    arma::Mat<double> sequence(seed.n_elem, numberOfElements);
    // A Hammersley set is generated by producing a Van der Corput sequence for each dimension, except for the last element of each dimension.
    // The last element is equal to n/*numberOfElements* (n = the dimension's index).
    for (arma::uword n = 0; n < seed.n_elem; ++n) {
      sequence.submat(n, 0, n, numberOfElements - 2) = vanDerCorputSequence(base(n), seed(n), numberOfElements - 1).t();
      sequence.submat(n, numberOfElements - 1, n, numberOfElements - 1) = static_cast<double>(n + 1) / static_cast<double>(numberOfElements);
    }

    return sequence;
  }

  arma::Mat<double> haltonSequence(
      const arma::Col<arma::uword>& base,
      const arma::Col<arma::uword>& seed,
      const arma::uword numberOfElements) {
    verify(base.n_elem == seed.n_elem, "haltonSequence: The number of dimensions of the base parameter must match the number of dimensions of the seed parameter.");

    arma::Mat<double> sequence(seed.n_elem, numberOfElements);
    // A Halton sequence is generated by producing a Van der Corput sequence for each dimension.
    for (arma::uword n = 0; n < seed.n_elem; ++n) {
      sequence.row(n) = vanDerCorputSequence(base(n), seed(n), numberOfElements).t();
    }

    return sequence;
  }

  arma::Col<double> vanDerCorputSequence(
      const arma::uword base,
      const arma::uword seed,
      const arma::uword numberOfElements) {
    arma::Col<double> sequence(numberOfElements);

    for (arma::uword n = 0; n < numberOfElements; ++n) {
      // The resulting sequence must be within [0, 1], wherefore the base is used to divide this range into equal intervals.
      // For example: Given *base* = 3, the range will be divided into the 3 intervals {[0, 1/3), [1/3, 2/3), [2/3, 1)}.
      double inverse = 1.0 / static_cast<double>(base);
      // The number to be added to the sequence later on.
      double number = 0.0;

      // Determines how often should we further divide one of the interval.
      arma::uword remaining = seed + n;
      // The first iteration will divide one interval into *base* subintervals, the second one will further divide one subinterval into *base* subsubintervals, and so on.
      while (remaining > 0) {
        // Determines which interval is selected.
        arma::uword digit = remaining % base;
        // Adds the lower interval bound to *number*.
        number += static_cast<double>(digit) * inverse;
        // Reduces the step size within the current interval, effectively dividing the selected interval into *base* smaller intervals.
        // The next iteration will than operate only within these smaller intervals.
        // For example: Given *remaining* = 2, *base* = 3 and *inverse* = 1/3, the [2/3, 1) interval is divided into {[2/3, 7/9), [7/9, 8/9), [8/9, 1)}.
        inverse /= static_cast<double>(base);
        // The result will already be floored, as both values are integer types.
        remaining /= base;
      }

      sequence(n) = number;
    }

    return sequence;
  }

  std::vector<std::pair<arma::Col<arma::uword>, arma::Col<arma::uword>>> twoSetsPartitions(
      const arma::uword numberOfElements) {
    std::vector<std::pair<arma::Col<arma::uword>, arma::Col<arma::uword>>> partitions;

    // There is no differentiation on the order of both sets within a partition. For example {{0, 1, 2}, {3}} and {{3}, {0, 1, 2}} are the same partition, which is why the first set can be limited to *numberOfElements*/2 elements, without excluding any partition.
    arma::Col<arma::uword> elements = range(0, numberOfElements - 1);
    for (arma::uword n = 1; n <= std::floor(static_cast<double>(numberOfElements) / 2.0); ++n) {
      arma::Col<arma::uword> firstSet = elements.head(n);
      arma::Col<arma::uword> secondSet = elements.tail(elements.n_elem - n);

      partitions.push_back({firstSet, secondSet});

      arma::Col<arma::uword> counter(n, arma::fill::zeros);
      arma::uword shiftedIndex = counter.n_elem;

      arma::uword lastIndex = 0;
      // For the special case that the combination would be split into equal parts, we fixate the first element to be zero, to avoid multiple insertions of the same partition, like {{0, 1}, {2, 3}} and {{2, 3}, {{1, 0}}.;
      if (firstSet.n_elem == secondSet.size()) {
        lastIndex = 1;
      }

      while (shiftedIndex > lastIndex) {
        const arma::uword index = shiftedIndex - 1;

        std::iter_swap(firstSet.begin() + index, secondSet.begin() + counter(index));
        partitions.push_back({firstSet, secondSet});

        if (counter(index) < secondSet.n_elem - 1) {
          counter.tail(counter.n_elem - index).fill(counter(index) + 1);
          shiftedIndex = counter.n_elem;
        } else {
          --shiftedIndex;
        }
      }
    }

    return partitions;
  }
}
