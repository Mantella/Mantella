#pragma once

/**

*/
  arma::mat hammersleySet(
      const arma::uvec& bases,
      const arma::uvec& seeds,
      const arma::uword numberOfElements) {
    assert(!bases.is_empty() && "hammersleySet: The bases must not be empty.");
    assert(arma::size(bases) == arma::size(seeds) && "hammersleySet: The number of bases must be equal to the number of seeds.");
    assert(arma::all(bases > 1) && "hammersleySet: All bases must be greater than 1.");

    if (numberOfElements == 0) {
      return {};
    }

    if (!isRepresentableAsFloatingPoint(seeds.n_elem)) {
      throw std::range_error("hammersleySet: The number of seeds must be representable as a floating point.");
    } else if (!isRepresentableAsFloatingPoint(numberOfElements)) {
      throw std::range_error("hammersleySet: The number of elements must be representable as a floating point.");
    }

    // A Hammersley set is generated by producing a Van der Corput sequence for each dimension and skipping the last element of each dimension.
    // The last element is than set to n / `numberOfElements` (n = the dimension).
    arma::mat sequence(seeds.n_elem, numberOfElements);
    for (arma::uword n = 0; n < sequence.n_rows; ++n) {
      if (numberOfElements > 1) {
        sequence.submat(n, 0, n, numberOfElements - 2) = vanDerCorputSequence(bases(n), seeds(n), numberOfElements - 1).t();
      }
      sequence(n, numberOfElements - 1) = static_cast<double>(n + 1) / static_cast<double>(numberOfElements);
    }

    return sequence;
  }