/**
Problems
========

.. cpp:class:: problem

  .. list-table:: Template parameters
    :widths: 27 73
    
    * - T
        
        Any floating point type
      - The value type of the parameter and objective value.
    * - N
        
        ``unsigned``
      - The number of dimensions.
        
        Must be within ``[1, std::numeric_limits<unsigned>::max()]``.
        
        For cases where the number of dimensions can be lowered during run-time (for example separable problems), the
        :cpp:any:`optimiser` can be told to focus on specific domains by specifying ``.active_dimensions``.
        
        You can also reduce the computational cost for time-consuming objective value calculations, by capturing the 
        active dimensions in ``.objective_function``:
        
        .. code-block:: c++
        
          #include <mantella0>
          #include <iostream> // Used for std::cout
          #include <iterator> // Used for std::ostream_iterator
          
          int main() {
            mant::problem<double, 3> my_problem;
            // Only the first and third dimension are active.
            const std::array<unsigned, 2> active_dimensions = {0, 2};
            my_problem.objective_function = [&active_dimensions](const auto& parameter) {
              double objective_value = 0.0;
              for (unsigned n = 0; n < active_dimensions.size(); ++n) {
                // Make sure this computation is actually a heavy-weight. Otherwise, the additional memory lookups and 
                // code complexity might not be worth it.
                // How can you ensure this? Benchmarking, benchmarking and benchmarking ;)
                objective_value += std::pow(parameter.at(active_dimensions.at(n)), 2.0);
              }
              return objective_value;
            };

            // Optimises your problem. Selects and tunes the optimiser automatically at each invocation.
            const auto&& result = mant::optimise(my_problem);

            // Prints out the best parameter and its objective value
            std::copy(result.parameter.cbegin(), result.parameter.cend(), std::ostream_iterator<double>(std::cout, " "));
            std::cout << "-> " << result.objective_value << std::endl;
            
            return 0;
          }
  
  .. list-table:: Member variables
    :widths: 27 73
    
    * - objective_function
        
        ``std::function<T(parameter)>``
      - This is the function under optimisation.
        
        This variable is empty as default.
        
        **Function parameters**
        
        - **parameter** ``(std::array<T, N>)``
        
          A parameter (usually generated by an :cpp:any:`optimiser`), for which its objective value is requested. 
          
          While the parameter can contain any value (even ``NaN``), it will be bounded within ``[lower_bounds, upper_bounds]`` if generated | by Mantella's optimisers.
            
        **Returns** ``(T)``
        
          The parameter's objective value.
          
          As most :cpp:any:`optimiser` use this value for ranking purpose, avoid non-comparable values (like ``NaN``).
          
    * - lower_bounds
        
        ``std::array<T, N>``
      - The search space's lower bounds.
        
        Must be lesser than or equal to the upper ones.
        
    * - upper_bounds
        
        ``std::array<T, N>``
      - The search space's upper bounds.
        
        Must be greater than or equal to the lower ones.

  .. list-table:: Member functions
    :widths: 27 73
    
    * - problem
    
        (Constructor)
      - Initialises all member variables to their default value.
    
.. toctree::
  
  problem/ackley_function
  problem/rastrigin_function
  problem/rosenbrock_function
  problem/sphere_function
  problem/sum_of_different_powers_function
*/
template <typename T, unsigned N>
struct problem {
  std::function<T(
      const std::array<T, N>& parameter)> objective_function;
  
  std::array<T, N> lower_bounds;
  std::array<T, N> upper_bounds;
  
  constexpr problem() noexcept;
};

//
// Implementation
//

template <typename T, unsigned N>
constexpr problem<T, N>::problem() noexcept {
  static_assert(std::is_floating_point<T>::value, "");
  static_assert(N > 0, "");
  
  // These bounds could be anything as default, as they need user-given, context-dependent knowledge to be useful.
  // However, since we map the bounds later on internally to [0, 1] to ease maintainability in our optimisation 
  // algorithms, we use [0, 1] as default.
  lower_bounds.fill(T(0.0));
  upper_bounds.fill(T(1.0));
}

//
// Unit tests
//

#if defined(MANTELLA_BUILD_TESTS)
TEST_CASE("problem", "[problem]") {
  const mant::problem<double, 2> problem;
  
  CHECK((problem.lower_bounds == std::array<double, 2>({0.0, 0.0})));
  CHECK((problem.upper_bounds == std::array<double, 2>({1.0, 1.0})));
}
#endif
