/**
Problems
========

.. cpp:class:: problem

  .. versionadded:: 1.0.0 

  Defining an optimisation problem is usually the first of two step done when working with Mantella (the second one will be calling `:cpp:any:`optimise`, to *solve* the problem).
  
  As we are focused on optimising black-box/derivative-free problems (.i.e. problems without a known/primitive first- or second-order derivative), 
  
  This ``struct`` contains 
  
  .. code-block:: c++
  
    #include <mantella0>
    
    double some_function() {
      return 0.0;
    }
    
    int main() {
      
      mant::problem<double, 3> problem;
      
      return 0;
    }
  

  .. list-table:: Template parameters
    :widths: 27 73
    
    * - T
        
        Any floating point type
      - The value type of the parameter and objective value.
    * - N
        
        ``unsigned``
      - The number of dimensions.
        
        Must be within ``[1, std::numeric_limits<unsigned>::max()]``.
        
        For cases where the number of dimensions can be lowered during run-time (for example separable problems), the
        :cpp:any:`optimiser` can be told to focus on specific domains by specifying ``.active_dimensions``.
        
        You can also reduce the computational cost for time-consuming objective value calculations, by capturing the 
        active dimensions:
        
        .. code-block:: c++
        
          #include <mantella0>
          #include <iostream> // Used for std::cout
          #include <iterator> // Used for std::ostream_iterator
          
          int main() {
            constexpr unsigned number_of_dimensions = 3;
            const std::vector<unsigned> active_dimensions = {0, 2};
            
            mant::problem<double, number_of_dimensions> problem;
            // Only the first and third dimension are active.
            // Captures *active_dimensions*.
            problem.objective_function = [&active_dimensions](const auto& parameter) {
              double objective_value = 0.0;
              for (unsigned n = 0; n < active_dimensions.size(); ++n) {
                // Make sure this computation is actually a heavy-weight. Otherwise, the additional memory 
                // lookup and code complexity might not be worth it.
                // How to ensure this? Benchmarking, benchmarking and benchmarking ;)
                objective_value += parameter.at(active_dimensions.at(n));
              }
              return objective_value;
            };
            problem.lower_bounds.fill(-5.0);
            problem.upper_bounds.fill(5.0);

            mant::hooke_jeeves_algorithm<double, number_of_dimensions> optimiser;
            // Explicitly tells the optimiser to ignore the second dimension.
            // This can also be done if the objective value is inexpensive to compute, as it speeds up
            // the optimisation process by reducing the search space's dimensionality.
            optimiser.active_dimensions = active_dimensions;
            
            // The best parameter will be (-5, x, -5) with objective value -10. *x* can anything, as the 
            // second dimension is inactive. 
            const auto&& result = mant::optimise(problem, optimiser);
            std::copy(result.parameter.cbegin(), result.parameter.cend(), std::ostream_iterator<double>(std::cout, " "));
            std::cout << "-> " << result.objective_value << std::endl;
            
            return 0;
          }
  
  .. list-table:: Member variables
    :widths: 27 73
    
    * - objective_function
        
        ``std::function``
      - The function to be optimised. Calculates an objective value for the given parameter.
        
        This variable is empty as default. Therefore, it must be set, before a :cpp:any:`problem` can be optimised.
        
        **Function parameters**
        
        - **parameter** ``(std::array<T, N>)``
        
          A parameter (usually generated by an :cpp:any:`optimiser`), for which its objective value is requested. 
          
          While the parameter can contain any value (even ``NaN``), it will be bounded within ``[lower_bounds, upper_bounds]`` if generated by Mantella's optimisers.
          
          As The parameter is a fixed-sized ``std::array``, it will always contain ``N`` elements. However, if the :cpp:any:`optimiser`'s ``.active_dimensions`` was set, Mantella's optimisers will only optimise the active dimensions. The other dimensions may contain any value, which won't change until the optimisation processes (i.e. ``.optimisation_function``) finishes.
            
        **Returns** ``(T)``
        
          The parameter's objective value.
          
          As most :cpp:any:`optimiser` use this value for ranking purpose, avoiding non-comparable values (like ``NaN``) is critical.
          
    * - lower_bounds
        
        ``std::array<T, N>``
      - The search space's lower bounds.
        
        Must be lesser than or equal to the upper ones.
        
        Since most :cpp:any:`optimiser` integrate the bounds into their calculations, infinite values should be avoided as boundary.
        
        The default lower bound is ``(0, 0, ..., 0)``.
        
    * - upper_bounds
        
        ``std::array<T, N>``
      - The search space's upper bounds.
        
        Must be greater than or equal to the lower ones.
        
        Since most :cpp:any:`optimiser` integrate the bounds into their calculations, infinite values should be avoided as boundary.
        
        The default upper bound is ``(1, 1, ..., 1)``.

  .. list-table:: Member functions
    :widths: 27 73
    
    * - problem
    
        Constructor
      - Initialises all member variables to their default value.
      
        Will never throw an exception.
    
Below is a list of common problems we implemented, to quickly get a feeling for the library, without the need to implement your own problem yet. These problems are also used in our benchmarks to compare against other optimisation libraries.

.. include:: problem/ackley_function.include
.. include:: problem/rastrigin_function.include
.. include:: problem/rosenbrock_function.include
.. include:: problem/sphere_function.include
.. include:: problem/sum_of_different_powers.include
*/
template <typename T, unsigned N>
struct problem {
  std::function<T(
      const std::array<T, N>& parameter)> objective_function;
  
  std::array<T, N> lower_bounds;
  std::array<T, N> upper_bounds;
  
  constexpr problem() noexcept;
};

//
// Implementation
//

template <typename T, unsigned N>
constexpr problem<T, N>::problem() noexcept {
  static_assert(std::is_floating_point<T>::value, "");
  static_assert(N > 0, "");
  
  // These bounds could be anything as default, as they need user-given, context-dependent knowledge to be useful.
  // However, since we map the bounds later on internally to [0, 1] to ease maintainability in our optimisation 
  // algorithms, we use [0, 1] as default.
  lower_bounds.fill(T(0.0));
  upper_bounds.fill(T(1.0));
}

//
// Unit tests
//

#if defined(MANTELLA_BUILD_TESTS)
TEST_CASE("problem", "[problem]") {
  const mant::problem<double, 2> problem;
  
  CHECK((problem.lower_bounds == std::array<double, 2>({0.0, 0.0})));
  CHECK((problem.upper_bounds == std::array<double, 2>({1.0, 1.0})));
}
#endif
